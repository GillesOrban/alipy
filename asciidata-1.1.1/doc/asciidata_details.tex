%
% Section the asciidata class
%
\subsection{The AsciiData class}
\label{adclass}
\index{classes}\index{classes!AsciiData}
\index{AsciiData class}
The \ad class is the central class in the \AAD module.
After creating \ad objects with one of the functions introduced in
Sect.\ \ref{functions}, the returned objects are modified using
its methods.

\subsubsection{AsciiData data}
\label{add}
\index{class data}\index{AsciiData!data}
\ad objects contain some information which is important to the user
and can be used in the processing. Although it is possible,
this class data should {\bf never} be changed directly by the user.
All book-keeping is done internally such that e.g. the value of
{\tt ncols} is adjusted when deleting a column.

\prgrf{Data}
\begin{tabular}{lcl}
filename &{\it string}& file name associated to the object\\
ncols    &{\it int}& number of columns\\
nrows    &{\it int}& number of rows\\
\end{tabular}

\prgrf{Examples}
\begin{enumerate}
\item Go over all table entries an store values:
\begin{small}
\begin{verbatim}
>>> example3 = asciidata.create(100,100)
>>> for cindex in range(example3.ncols):
...     for rindex in range(example3.nrows):
...             example3[cindex][rindex] = do_something(rindex, rindex)
...
\end{verbatim}
\end{small}
\item Derive a new filename and save the table to this filename:
\begin{verbatim}
>>> print example2.filename
example2.txt
>>> newname = example2.filename + '.old'
>>> print newname
example2.txt.old
>>> example2.writeto(newname)
\end{verbatim}
\end{enumerate}

\subsubsection{AsciiData method get}
\label{adm_get}
\index{methods}\index{methods!AsciiData!get}
\index{get}
%
This method retrieves list members of an \ad instance. These list members are the \ac instances
(see Sect.\ \ref{acclass}), which are accessed via their column name {\bf or}
column number.\\
The method returns only the {\it reference} to the column, therefore changing the returned \ac instance means also changing the original \ad
instance (see Example 2)! To get a deep copy of an \ac the
method {\tt copy} of the \ac class itself (see Sect. \ref{acm_copy}) must be
used instead.

\prgrf{Usage}
adata\_column = adata\_object[col\_spec]\\
{\it or}\\
adata\_column = operator.getitem(adata\_object, col\_spec)

\prgrf{Parameters}
\begin{tabular}{lcl}
col\_spec &{\it string/int}& column specification, either by column name or column number\\
\end{tabular}

\prgrf{Return}
- an \ac instance

\prgrf{Examples}
\begin{enumerate}
\item Retrieve the second column of the table:
\begin{small}
\begin{verbatim}
>>> print example
#
# most important sources!!
#
    1  1.0  red  23.08932 -19.34509
    2  9.5 blue  23.59312 -19.94546
    3  3.5 blue  23.19843 -19.23571
>>> aad_col = example[1]
>>> print aad_col
Column: column2
 1.0
 9.5
 3.5
>>>
\end{verbatim}
\end{small}
\item Retrieve the second column of the table. Demonstrate that only
a shallow copy (reference) is returned:
\begin{small}
\begin{verbatim}
>>> print example
#
# most important sources!!
#
    1  1.0  red  23.08932 -19.34509
    2  9.5 blue  23.59312 -19.94546
    3  3.5 blue  23.19843 -19.23571
>>> ad_col = operator.getitem(example, 'column1')
>>> print ad_col
Column: column1
    1
    2
    3
>>> ad_col[1] = 'new!'
>>> print ad_col
Column: column1
   1
new!
   3
>>> print example
#
# most important sources!!
#
   1  1.0  red  23.08932 -19.34509
new!  9.5 blue  23.59312 -19.94546
   3  3.5 blue  23.19843 -19.23571
>>>
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method set}
\label{adm_set}
\index{methods}\index{methods!AsciiData!set}
\index{set}
%
This methods sets list members, which means columns, of an \ad instance.
The list member to be changed is addressed either via its column name or
the column number.\\
Obviously the replacing object must be an \ac instance which contains
an equal number of rows. Otherwise an exception is risen.

\prgrf{Usage}
adata\_object[col\_spec] = adata\_column\\
{\it or}\\
operator.setitem(adata\_object, col\_spec, adata\_column)


\prgrf{Parameters}
\begin{tabular}{lcl}
col\_spec &{\it string/int}& column specification, either by column name or column number\\
adata\_column &{\it AsciiColumn}& the \ac instance to replace the previous column\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Replace the third row of the table 'exa\_1' with the third row of table 'exa\_2'.
Please note the interplay between the {\tt get}- and the {\tt set}-method of
the \ad class:
\begin{tiny}
\begin{verbatim}
>>> exa_1 = asciidata.open('some_objects.cat')
>>> exa_2 = asciidata.open('some_objects_2.cat', delimiter='|', comment_char='@', null='*')
>>> print exa_1
#
# most important objects
#
    1  1.0  red  23.08932 -19.34509
    2  9.5 blue  23.59312 -19.94546
    3  3.5 blue  23.19843 -19.23571
>>> print exa_2
@
@
@
   10| 0.0|  pink | 130.3757| 69.87343
   25| 5.3| green | 130.5931| 69.89343
   98| 3.5|      *| 130.2984| 69.30948
>>> exa_1[2] = exa_2[2]
>>> print exa_1
#
# most important objects
#
    1  1.0   pink   23.08932 -19.34509
    2  9.5  green   23.59312 -19.94546
    3  3.5    Null  23.19843 -19.23571
>>>
\end{verbatim}
\end{tiny}
\end{enumerate}

\subsubsection{AsciiData method writeto()}
\label{adm_writeto}
\index{methods}\index{methods!AsciiData!writeto()}
\index{writeto()}
Write the \ad object to a file. The file name is given in a parameter.
Independent of the catalogue format (plain or SExtractor) two parameters
control whether the column information and the header comment are also
written to the new file.

By default the header comments are always written to the file, the column info
only for the SExtractor format.

\prgrf{Usage}
 adata\_object.writeto(filename, colInfo, headComment)

\prgrf{Parameters}
\begin{tabular}{lccl}
Name     & Type    & Default & Description \\ \hline
filename &{\it string}& - & the filename to save the \ad object to\\
colInfo & {\it int}& {\it None} & write column info ($=1$) or not($=0$)\\
headComment & {\it int}& {\it None} & write header comment ($=1$) or not($=0$)\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Write an \ad object to the file 'newfile.txt':
\begin{small}
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.writeto('newfile.txt')
>>>
> more newfile.txt
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\end{small}
\end{enumerate}



\subsubsection{AsciiData method writetofits()}
\label{adm_writetofits}
\index{methods}\index{methods!AsciiData!writetofits()}
\index{writetofits()}
%
The method transforms an \ad instance to a fits-table and stores
the fits-table to the disk. The filename is either specified as a parameter
or is derived from the filename of the original ascii-table. In the latter
case the file extension is changed to '.fits'.\\
The module \index{PyFITS}{\tt PyFITS} (see \htmladdnormallink{http://www.stsci.edu/resources/software\_hardware/pyfits}{http://www.stsci.edu/resources/software_hardware/pyfits})
must be installed to run this method. The transformation fails if the
\ad instance contains any {\tt Null} elements (due to a limitation
of the {\tt numpy} and {\tt numarray} objects, which are essential for the
method).

\prgrf{Usage}
aad\_object.writetofits(fits\_name=None)


\prgrf{Parameters}
\begin{tabular}{lcl}
fits\_name & {\it string} & the name of the fits-file\\
\end{tabular}

\prgrf{Return}
- the fits file to which the \ad instance was written

\prgrf{Examples}
\begin{enumerate}
\item Store an \ad instance as a fits-file, using the default name:
\begin{small}
\begin{verbatim}
test>ls
some_objects.cat
test>python
Python 2.4.2 (#1, Nov 10 2005, 11:34:38)
[GCC 3.3.3 20040412 (Red Hat Linux 3.3.3-7)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import asciidata
>>> exa = asciidata.open('some_objects.cat')
>>> fits_name = exa.writetofits()
>>> fits_name
'some_objects.fits'
>>>
test>ls
some_objects.cat  some_objects.fits
test>
\end{verbatim}
\end{small}


\item Store an \ad instance to the fits-file 'test.fits':
\begin{small}
\begin{verbatim}
test>ls
some_objects.cat
test>python
Python 2.4.2 (#1, Nov 10 2005, 11:34:38)
[GCC 3.3.3 20040412 (Red Hat Linux 3.3.3-7)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import asciidata
>>> exa = asciidata.open('some_objects.cat')
>>> fits_name = exa.writetofits('test.fits')
>>> fits_name
'test.fits'
>>>
test>ls
some_objects.cat  test.fits
test>
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method writetohtml()}
\label{adm_writetohtml}
\index{methods}\index{methods!AsciiData!writetohtml()}
\index{writetohtml()}
%
The method writes the data of an \ad instance formatted as the content of
an html-table to the disk. Strings used as attributes can be specified
for the tags {\tt<tr>} and {\tt <td>}. The name of the html-file is either
given as parameter or is derived from the name of the original ascii-table.
In the latter case the file extension is changed to '.html'.\\
The html-table is neither opened nor closed at
the beginning and end of the file, respectively. Also column names and
other meta information is NOT used in the html.

\prgrf{Usage}
aad\_object.writetohtml(html\_name=None, tr\_attr=None, td\_attr=None)

\prgrf{Parameters}
\begin{tabular}{lcl}
html\_name & {\it string} & the name of the html-file\\
tr\_attr & {\it string} & attribute string for the tr-tag\\
td\_attr & {\it string} & attribute string for the td-tag\\
\end{tabular}

\prgrf{Return}
- the name of the html-file

\prgrf{Examples}
\begin{enumerate}
\item Write an \ad instance to an html-file:
\begin{small}
\begin{verbatim}
>>> exa = asciidata.open('some_objects.cat')
>>> exa.writetohtml()
'some_objects.html'
>>>
test>more 'some_objects.html'
<tr><td>    1</td><td> 1.0</td><td> red</td><td> 23.08932</td><td>-19.34509</td></tr>
<tr><td>    2</td><td> 9.5</td><td>blue</td><td> 23.59312</td><td>-19.94546</td></tr>
<tr><td>    3</td><td> 3.5</td><td>blue</td><td> 23.19843</td><td>-19.23571</td></tr>
test>
\end{verbatim}
\end{small}
\item Write an \ad instance to the html-file 'mytab.tab', using attributes
for the tags:
\begin{small}
\begin{verbatim}
>>> exa = asciidata.open('some_objects.cat')
>>> html_name = exa.writetohtml('mytab.tab',tr_attr='id="my_tr"',td_attr='bgcolor="RED"')
>>> print html_name
mytab.tab
>>>
test>more mytab.tab
<tr id="my_tr"><td bgcolor="RED">    1</td><td bgcolor="RED"> 1.0</td><td bgcolor="RED">
 red</td><td bgcolo
r="RED"> 23.08932</td><td bgcolor="RED">-19.34509</td></tr>
<tr id="my_tr"><td bgcolor="RED">    2</td><td bgcolor="RED"> 9.5</td><td bgcolor="RED">
blue</td><td bgcolo
r="RED"> 23.59312</td><td bgcolor="RED">-19.94546</td></tr>
<tr id="my_tr"><td bgcolor="RED">    3</td><td bgcolor="RED"> 3.5</td><td bgcolor="RED">
blue</td><td bgcolo
r="RED"> 23.19843</td><td bgcolor="RED">-19.23571</td></tr>
test>
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method writetolatex()}
\label{adm_writetolatex}
\index{methods}\index{methods!AsciiData!writetolatex()}
\index{writetolatex()}
%
The method writes the data of an \ad instance, formatted as the content of
a \htmladdnormallink{\LaTeX table}{http://en.wikibooks.org/wiki/LaTeX/Tables},
to the disk. The name of the \LaTeX file is either given as parameter or is
derived from the name of the original ascii-table.
In the latter case the file extension is changed '.tex'.

\prgrf{Usage}
aad\_object.writetolatex(latex\_name=None)


\prgrf{Parameters}
\begin{tabular}{lcl}
latex\_name & {\it string} & the name of the latex-file\\
\end{tabular}

\prgrf{Return}
- the name of the latex-file

\prgrf{Examples}
\begin{enumerate}
\item Write the content of an \ad instance to 'latextab.tb':
\begin{small}
\begin{verbatim}
>>> exa = asciidata.open('some_objects.cat')
>>> latex_name = exa.writetolatex('latex.tb')
>>> print latex_name
latex.tb
>>>
test>more latex.tb
    1& 1.0& red& 23.08932&-19.34509\\
    2& 9.5&blue& 23.59312&-19.94546\\
    3& 3.5&blue& 23.19843&-19.23571\\
test>
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method sort()}
\label{adm_sort}
\index{methods}\index{methods!AsciiData!sort()}
\index{sort()}
%
This method sorts the data in an \ad instance according to the values
in a specified column. Sorting in ascending and descending order is
possible.\\
There are two different sorting algorithms implemented. A fast algorithm
which is based on recursion can be used for making a single, 'isolated' sort
process ({\tt ordered=0}).

However the fast algorithm can break, e.g. when sorting an already sorted table
(e.g. descending) in the opposite direction (ascending). Then the maximum
recursion depth of python can be reached, causing a failure.
In addition, fast recursive algorithms introduce random swaps of rows, which
is counterproductive if the desired result of the sort process can only
be reached with consequtive sortings on different columns (see
examples 3 and 4 below).

In these cases a slower sorting algorithm must be used which is evoked
with the parameter {\tt ordered=1}.

\prgrf{Usage}
adata\_object.sort(colname, descending=0, ordered=0)

\prgrf{Parameters}
\begin{tabular}{lcl}
colname & {\it string/integer} & the specification of the sort column\\
descending & {\it integer} & sort in ascending ($=0$) or descending ($=1$) order\\
ordered & {\it integer} & use the fast ($=0$) algorithm or the slow ($=1$)\\
        &               & which avoids unnecessary row swaps\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Sort a table in ascending order of the values in the second column:
\begin{small}
\begin{verbatim}
>>> sort = asciidata.open('sort_objects.cat')
>>> print sort
    1     0     1     1
    2     1     0     3
    3     1     2     4
    4     0     0     2
    5     1     2     1
    6     0     0     3
    7     0     2     4
    8     1     1     2
    9     0     1     5
   10     1     2     6
   11     0     0     6
   12     1     1     5
>>> sort.sort(1)
>>> print sort
    1     0     1     1
    6     0     0     3
    9     0     1     5
   11     0     0     6
    7     0     2     4
    4     0     0     2
   12     1     1     5
    2     1     0     3
   10     1     2     6
    3     1     2     4
    5     1     2     1
    8     1     1     2
>>>
\end{verbatim}
\end{small}

\item Use the result from example 1, and sort the table in descending
order of the first column:
\begin{small}
\begin{verbatim}
>>> sort.sort(0, descending=1)
>>> print sort
   12     1     1     5
   11     0     0     6
   10     1     2     6
    9     0     1     5
    8     1     1     2
    7     0     2     4
    6     0     0     3
    5     1     2     1
    4     0     0     2
    3     1     2     4
    2     1     0     3
    1     0     1     1
>>>
\end{verbatim}
\end{small}

\item Sort the table first along column 3 and then along column 2. The
resulting table is sorted along column 2, but in addition it is
ordered along column 3 for equal values in column 2.
This works only using the slower, ordered sorting algorithm:
\begin{small}
\begin{verbatim}
>>> sort.sort(2, ordered=1)
>>> sort.sort(1, ordered=1)
>>> print sort
   11     0     0     6
    6     0     0     3
    4     0     0     2
    9     0     1     5
    1     0     1     1
    7     0     2     4
    2     1     0     3
   12     1     1     5
    8     1     1     2
   10     1     2     6
    5     1     2     1
    3     1     2     4
>>>
\end{verbatim}
\end{small}
\item As the previous example, but using the faster, un-ordered sorting
algorithm. The result differs from the previous example, since the fast
algorithm does {\bf not} preserve the sorting in column 3 for equal values in
column 2:
\begin{small}
\begin{verbatim}
>>> sort.sort(2, ordered=0)
>>> sort.sort(1, ordered=0)
>>> print sort
    1     0     1     1
    4     0     0     2
    7     0     2     4
   11     0     0     6
    9     0     1     5
    6     0     0     3
   12     1     1     5
    2     1     0     3
    3     1     2     4
   10     1     2     6
    5     1     2     1
    8     1     1     2
>>>
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method len()}
\label{adm_len}
\index{methods}\index{methods!AsciiData!len()}
\index{len()}
%
This method defines a length for every \ad instance, which is the number
of columns.

\prgrf{Usage}
len(aad\_object)

\prgrf{Parameters}
-

\prgrf{Return}
- the length of the \ad instance

\prgrf{Examples}
\begin{enumerate}
\item Determine and print the length of an \ad instance:
\begin{small}
\begin{verbatim}
>>> exa = asciidata.open('some_objects.cat')
>>> print exa
#
# most important objects
#
    1  1.0  red  23.08932 -19.34509
    2  9.5 blue  23.59312 -19.94546
    3  3.5 blue  23.19843 -19.23571
>>> length = len(exa)
>>> print length
5
>>>
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData iterator type}
\label{adm_iterator}
\index{methods}\index{methods!AsciiData!iterator}
\index{iterator}
%
This defines an iterator over an \ad instance. The iteration is finished after
{\tt aad\_object.ncols} calls and returns each column in subsequent calls.
Please note that it is {\bf not} possible to change these columns.

\prgrf{Usage}
for iter in aad\_object:\\
... $<do\ something>$

\prgrf{Parameters}
-

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Iterate over an \ad instance and print each column name:
\begin{small}
\begin{verbatim}
>>> exa = asciidata.open('sort_objects.cat')
>>> for col in exa:
...     print col.colname
...
column1
column2
column3
column4
>>>
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method append()}
\label{adm_append}
\index{methods}\index{methods!AsciiData!append()}
\index{append()}
Invoking this method is the formal way to append an new column
to and \ad object. When created there are only {\tt Null} entries in the
new column. The alternative way is just to specify a column
with an unknown name (see Sect.\ \ref{existingdata}).

\prgrf{Usage}
adata\_object.append(col\_name)

\prgrf{Parameters}
\begin{tabular}{lcl}
col\_name &{\it string}& the name of the new column\\
\end{tabular}

\prgrf{Return}
- the number of the columns created

\prgrf{Examples}
\begin{enumerate}
\item Append a new column {\tt 'newcolumn'} to the \ad object:
\begin{small}
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy  $            * $  62.2376331 $  24.97 $  0.15
   star  $  189.1409453 $  62.1696844 $  25.30 $     *
       * $  188.9014716 $           * $  25.95 $  0.20
>>> cnum = example2.append('newcolumn')
>>> print cnum
5
>>> print example2
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87 $  0.32 $          *
 galaxy  $            * $  62.2376331 $  24.97 $  0.15 $          *
   star  $  189.1409453 $  62.1696844 $  25.30 $     * $          *
       * $  188.9014716 $           * $  25.95 $  0.20 $          *
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method str()}
\label{adm_str}
\index{methods}\index{methods!AsciiData!str()}
\index{str()}
This methods converts the whole \ad object into a string.
Columns are separated with the delimiter, empty elements are represented
by the Null-string and the header is indicated by a comment-string at
the beginning. In this method the class object appears as a function
argument and the method call is different from the usual form such as
in Sect.\ \ref{adm_append}

\prgrf{Usage}
str(adata\_object)

\prgrf{Parameters}
-

\prgrf{Return}
- the string representing the \ad object

\prgrf{Examples}
\begin{enumerate}
\item Print an \ad object to the screen:
\begin{verbatim}
>>> print str(example2)
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy  $            * $  62.2376331 $  24.97 $  0.15
   star  $  189.1409453 $  62.1696844 $  25.30 $     *
       * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\item Store the sting representation of an \ad object:
\begin{verbatim}
>>> big_string = str(example2)
>>> print big_string
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy  $            * $  62.2376331 $  24.97 $  0.15
   star  $  189.1409453 $  62.1696844 $  25.30 $     *
       * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\end{enumerate}

\subsubsection{AsciiData method del}
\label{adm_del}
\index{methods}\index{methods!AsciiData!del}
\index{del}
This method deletes a column specified either by its name or
by the column number. Also this method call is slightly
different from the usual form such as in Sect.\ \ref{adm_append}
or \ref{adm_delete}.

\prgrf{Usage}
del adata\_obj[col\_spec]

\prgrf{Parameters}
\begin{tabular}{lcl}
col\_spec &{\it string/int}& column specification either by name or by
the column number\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Delete the column with name 'column5':
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy  $            * $  62.2376331 $  24.97 $  0.15
   star  $  189.1409453 $  62.1696844 $  25.30 $     *
       * $  188.9014716 $           * $  25.95 $  0.20
>>> del example2['column5']
>>> print example2
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87
 galaxy  $            * $  62.2376331 $  24.97
   star  $  189.1409453 $  62.1696844 $  25.30
       * $  188.9014716 $           * $  25.95
\end{verbatim}
\item Delete the second column:
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown  $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy  $            * $  62.2376331 $  24.97 $  0.15
   star  $  189.1409453 $  62.1696844 $  25.30 $     *
       * $  188.9014716 $           * $  25.95 $  0.20
>>> del example2[1]
>>> print example2
@
@ Some objects in the GOODS field
@
unknown  $  62.2357983 $  26.87 $  0.32
 galaxy  $  62.2376331 $  24.97 $  0.15
   star  $  62.1696844 $  25.30 $     *
       * $           * $  25.95 $  0.20
\end{verbatim}
\end{enumerate}

\subsubsection{AsciiData method delete()}
\label{adm_delete}
\index{methods}\index{methods!AsciiData!delete()}
\index{delete()}
This method deletes rows in an \ad object. The rows to be deleted
are specified in the parameters as start index and index of the
first row {\bf not} to be deleted. Deletes exactly one row if just
the start value is given.

\prgrf{Usage}
adata\_obj.delete(start, end=start+1)

\prgrf{Parameters}
\begin{tabular}{lcl}
start &{\it int}& the first row to be deleted\\
end   &{\it int}& the first row {\bf not} to be deleted\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Delete only row with index 1:
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.delete(1)
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\item Delete the row with index 0 and 1:
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.delete(0,2)
>>> print example2
@
@ Some objects in the GOODS field
@
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\end{enumerate}


\subsubsection{AsciiData method strip()}
\label{adm_strip}
\index{methods}\index{methods!AsciiData!strip()}
\index{strip()}
The method removes leading or trailing table rows which are either empty or
superfluous. Superfluous rows are marked by the argument given to the method.

\prgrf{Usage}
adata\_obj.strip(x=None)

\prgrf{Parameters}
\begin{tabular}{lcl}
x &{\it int/float/string}& filling value which indicates a superfluous entry\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Remove all empty rows from the table:
\begin{verbatim}
>>> print example
#
#
#
 Null  Null  Null  Null
    0     0  Null     1
 Null     9     8     0
 Null  Null  Null  Null
 Null  Null  Null  Null
>>> example.strip()
>>> print example
#
#
#
    0     0  Null     1
 Null     9     8     0
>>>
\end{verbatim}
\item Remove all rows which contain {\bf only} the value $-1$ from the table:
\begin{verbatim}
>>> print example
#
#
#
   -1    -1    -1    -1
    0     0    -1     1
   -1     9     8     0
   -1    -1    -1    -1
   -1    -1    -1    -1
>>> example.strip(-1)
>>> print example
#
#
#
    0     0    -1     1
   -1     9     8     0
>>>
\end{verbatim}
\end{enumerate}


\subsubsection{AsciiData method lstrip()}
\label{adm_lstrip}
\index{methods}\index{methods!AsciiData!lstrip()}
\index{lstrip()}
The method removes all table rows which are either empty or superfluous
from the top ($\equiv$ {\bf l}eft) of the table. Superfluous
rows are marked by the argument given to the method.

\prgrf{Usage}
adata\_obj.lstrip(x=None)

\prgrf{Parameters}
\begin{tabular}{lcl}
x &{\it int/float/string}& filling value which indicates a superfluous entry\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Remove all empty rows from the top of the table:
\begin{verbatim}
>>> print example
#
#
#
 Null  Null  Null  Null
    0     0  Null     1
 Null     9     8     0
 Null  Null  Null  Null
 Null  Null  Null  Null
>>> example.lstrip()
>>> print example
#
#
#
    0     0  Null     1
 Null     9     8     0
 Null  Null  Null  Null
 Null  Null  Null  Null
\end{verbatim}
\item Remove all rows which contain {\bf only} the value $-1$ from
the top of the table:
\begin{verbatim}
>>> print example
#
#
#
   -1    -1    -1    -1
    0     0    -1     1
   -1     9     8     0
   -1    -1    -1    -1
   -1    -1    -1    -1
>>> example.lstrip(-1)
>>> print example
#
#
#
    0     0    -1     1
   -1     9     8     0
   -1    -1    -1    -1
   -1    -1    -1    -1
>>>
\end{verbatim}
\end{enumerate}


\subsubsection{AsciiData method rstrip()}
\label{adm_rstrip}
\index{methods}\index{methods!AsciiData!rstrip()}
\index{rstrip()}
The method removes all table rows which are either empty or superfluous
from the bottom ($\equiv$ {\bf r}ight) of the table. Superfluous
rows are marked by the argument given to the method..

\prgrf{Usage}
adata\_obj.rstrip(x=None)

\prgrf{Parameters}
\begin{tabular}{lcl}
x &{\it int/float/string}& filling value which indicates a superfluous entry\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Remove all empty rows from the bottom  of the table:
\begin{verbatim}
>>> print example
#
#
#
 Null  Null  Null  Null
    0     0  Null     1
 Null     9     8     0
 Null  Null  Null  Null
 Null  Null  Null  Null
>>> example.rstrip()
>>> print example
#
#
#
 Null  Null  Null  Null
    0     0  Null     1
 Null     9     8     0
>>>
\end{verbatim}
\item Remove all rows which contain {\bf only} the value $-1$ from
the bottom of the table:
\begin{verbatim}
>>> print example
#
#
#
   -1    -1    -1    -1
    0     0    -1     1
   -1     9     8     0
   -1    -1    -1    -1
   -1    -1    -1    -1
>>> example.rstrip(-1)
>>> print example
#
#
#
   -1    -1    -1    -1
    0     0    -1     1
   -1     9     8     0
>>>
\end{verbatim}
\end{enumerate}

\subsubsection{AsciiData method find()}
\label{adm_find}
\index{methods}\index{methods!AsciiData!find()}
\index{find()}
The method determines the column number for a given column name.
The value -1 is returned if a column with this name does not exist.

\prgrf{Usage}
adata\_obj.find(col\_name)

\prgrf{Parameters}
\begin{tabular}{lcl}
col\_name &{\it string}& the name of the column\\
\end{tabular}

\prgrf{Return}
- the column number or -1 if the column does not exist

\prgrf{Examples}
\begin{enumerate}
\item Search for the column with name 'column3':
\begin{verbatim}
>>> example2 = asciidata.open('example2.txt', null='*', \
                              delimiter='$', comment_char='@')
>>> cnum = example2.find('column2')
>>> cnum
1
>>>
\end{verbatim}
\item Search for the column with the name 'not\_there':
\begin{verbatim}
>>> example2 = asciidata.open('example2.txt', null='*', \
                              delimiter='$', comment_char='@')
>>> cnum = example2.find('not_there')
>>> cnum
-1
>>>
\end{verbatim}
Obviously the \ad object example2 does not have a column with this name.
\end{enumerate}

\subsubsection{AsciiData method flush()}
\label{adm_flush}
\index{methods}\index{methods!AsciiData!flush()}
\index{flush()}
The method updates the associated file with the newest version of the
\ad object.

\prgrf{Usage}
adata\_obj.flush()

\prgrf{Parameters}
-

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Manipulate an \ad object and update the file:
\begin{small}
\begin{verbatim}
work>more example.txt
#
# Some objects in the GOODS field
#
unknown  189.2207323  62.2357983  26.87  0.32
 galaxy  189.1408929  62.2376331  24.97  0.15
   star  189.1409453  62.1696844  25.30  0.12
 galaxy  188.9014716  62.2037839  25.95  0.20
work>python
Python 2.4.2 (#5, Oct 21 2005, 11:12:03)
[GCC 3.3.2] on sunos5
Type "help", "copyright", "credits" or "license" for more information.
>>> import asciidata
>>> example = asciidata.open('example.txt')
>>> del example[4]
>>> example.flush()
>>>
work>more example.txt
#
# Some objects in the GOODS field
#
unknown  189.2207323  62.2357983  26.87
 galaxy  189.1408929  62.2376331  24.97
   star  189.1409453  62.1696844  25.30
 galaxy  188.9014716  62.2037839  25.95
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method info()}
\label{adm_info}
\index{methods}\index{methods!AsciiData!info()}
\index{info()}
The method returns an informative overview on the \ad object as
a string. This overview gives the user a quick insight
into e.g. the column names of the object.

The focus of the method clearly is the use in interactive work.
All information provided can be retrieved by \ac methods in
a machine readable format as well.

The overview contains:
\begin{itemize}
\item the name of the file associated to the \ad object;
\item the number of columns;
\item the number of rows;
\item the delimiter to separate columns;
\item the representing Null-values;
\item the comment string.
\end{itemize}
In addition, for every column the column name, type, format and
Null-representation is given.

\prgrf{Usage}
adata\_object.info()

\prgrf{Parameters}
-

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Print the information on an \ad object onto the screen:
\begin{small}
\begin{verbatim}
>>> example = asciidata.open('example.txt')
>>> print example.info()
File:       example.txt
Ncols:      4
Nrows:      4
Delimiter:  None
Null value: ['Null', 'NULL', 'None', '*']
Comment:    #
Column name:        column1
Column type:        <type 'str'>
Column format:      ['% 7s', '%7s']
Column null value : ['Null']
Column name:        column2
Column type:        <type 'float'>
Column format:      ['% 11.7f', '%12s']
Column null value : ['Null']
Column name:        column3
Column type:        <type 'float'>
Column format:      ['% 10.7f', '%11s']
Column null value : ['Null']
Column name:        column4
Column type:        <type 'float'>
Column format:      ['% 5.2f', '%6s']
Column null value : ['Null']
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method insert()}
\label{adm_insert}
\index{methods}\index{methods!AsciiData!insert()}
\index{insert()}
This method inserts empty rows into all columns of the \ad object.
The first parameters gives the number of rows to be inserted.
The second parameter controls where exactly the new, empty rows
are positioned. It specifies the index of the first, empty row.
By default the rows are inserted at the table start.

\prgrf{Usage}
adata\_object.insert(nrows, start=0)

\prgrf{Parameters}
\begin{tabular}{lcl}
nrows &{\it int}& number of rows to be inserted\\
start &{\it int}& index position of the first inserted column\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Insert two rows such that the first row will have the index 1:
\begin{small}
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.insert(2,1)
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
        * $            * $           * $      * $     *
        * $            * $           * $      * $     *
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method newcomment\_char()}
\label{adm_newcomment}
\index{methods}\index{methods!AsciiData!newcomment()}
\index{newcomment()}
The method defines a new comment string for an \ad object.

\prgrf{Usage}
adata\_object.newcomment\_char(comment\_char)

\prgrf{Parameters}
\begin{tabular}{lcl}
comment\_char &{\it string}& the string to indicate a comment\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Change the comment sign from '@' to '!!':
\begin{small}
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.newcomment_char('!!')
>>> print example2
!!
!! Some objects in the GOODS field
!!
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method newdelimiter()}
\label{adm_newdelimiter}
\index{methods}\index{methods!AsciiData!newdelimiter()}
\index{newdelimiter()}
This method specifies a new delimiter for an \ad object.

\prgrf{Usage}
adata\_object.newdelimiter(delimiter)

\prgrf{Parameters}
\begin{tabular}{lcl}
delimiter &{\it string}& the new delimiter to separate columns\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Change the delimiter sign from '\$' to '\verb+<>+':
\begin{small}
\begin{verbatim}
>>> print example2
!!
!! Some objects in the GOODS field
!!
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.newdelimiter('<>')
>>> print example2
!!
!! Some objects in the GOODS field
!!
unknown   <>  189.2207323 <>  62.2357983 <>  26.87 <>  0.32
 galaxy   <>            * <>  62.2376331 <>  24.97 <>  0.15
   star   <>  189.1409453 <>  62.1696844 <>  25.30 <>     *
        * <>  188.9014716 <>           * <>  25.95 <>  0.20
\end{verbatim}
\end{small}
\end{enumerate}

\subsubsection{AsciiData method newnull()}
\label{adm_newnull}
\index{methods}\index{methods!AsciiData!newnull()}
\index{newnull()}
The method specifies a new string to represent Null-entries in an
\ad object.

\prgrf{Usage}
adata\_object.newnull(newnull)

\prgrf{Parameters}
\begin{tabular}{lcl}
newnull &{\it string}& the representation for Null-entries\\
\end{tabular}

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Change the Null representation from '*' to 'NaN':
\begin{small}
\begin{verbatim}
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $            * $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $     *
        * $  188.9014716 $           * $  25.95 $  0.20
>>> example2.newnull('NaN')
>>> print example2
@
@ Some objects in the GOODS field
@
unknown   $  189.2207323 $  62.2357983 $  26.87 $  0.32
 galaxy   $          NaN $  62.2376331 $  24.97 $  0.15
   star   $  189.1409453 $  62.1696844 $  25.30 $   NaN
      NaN $  188.9014716 $         NaN $  25.95 $  0.20
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method toplain()}
\label{adm_toplain}
\index{methods}\index{methods!AsciiData!toplain()}
\index{toplain()}

Change the format of the \ad object to 'plain'. As a consequence the column info
(names, units and comments) are no longer part of the output when e.g. writing the
object to a file.

\prgrf{Usage}
 adata\_object.toplain()

\prgrf{Parameters}
-

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Load an \ad object in the SExtractor format, change to plain format
and check the output.
\begin{small}
\begin{verbatim}
>>> SExample = asciidata.open('SExample.cat')
>>> print SExample
# 1  NUMBER  Running object number
# 2  XWIN_IMAGE  Windowed position estimate along x  [pixel]
# 3  YWIN_IMAGE  Windowed position estimate along y  [pixel]
# 4  ERRY2WIN_IMAGE  Variance of windowed pos along y [pixel**2]
# 5  AWIN_IMAGE  Windowed profile RMS along major axis  [pixel]
# 6  ERRAWIN_IMAGE  RMS windowed pos error along major axis  [pixel]
# 7  BWIN_IMAGE  Windowed profile RMS along minor axis  [pixel]
# 8  ERRBWIN_IMAGE  RMS windowed pos error along minor axis  [pixel]
# 9  MAG_AUTO  Kron-like elliptical aperture magnitude  [mag]
# 10 MAGERR_AUTO  RMS error for AUTO magnitude  [mag]
# 11 CLASS_STAR  S/G classifier output
    1  100.523  11.911  2.783  0.0693  2.078  0.0688 -5.3246  0.0416  0.00    19
    2  100.660  4.872  7.005  0.1261  3.742  0.0989 -6.4538  0.0214  0.00    27
    3  131.046  10.382  1.965  0.0681  1.714  0.0663 -4.6836  0.0524  0.00    17
    4  338.959  4.966  11.439  0.1704  4.337  0.1450 -7.1747  0.0173  0.00    25
    5  166.280  3.956  1.801  0.0812  1.665  0.0769 -4.0865  0.0621  0.00    25
>>> SExample.toplain()
>>> print SExample
    1  100.523  11.911  2.783  0.0693  2.078  0.0688 -5.3246  0.0416  0.00    19
    2  100.660  4.872  7.005  0.1261  3.742  0.0989 -6.4538  0.0214  0.00    27
    3  131.046  10.382  1.965  0.0681  1.714  0.0663 -4.6836  0.0524  0.00    17
    4  338.959  4.966  11.439  0.1704  4.337  0.1450 -7.1747  0.0173  0.00    25
    5  166.280  3.956  1.801  0.0812  1.665  0.0769 -4.0865  0.0621  0.00    25
\end{verbatim}
\end{small}
\end{enumerate}


\subsubsection{AsciiData method toSExtractor()}
\label{adm_toSExtractor}
\index{methods}\index{methods!AsciiData!toSExtractor()}
\index{toSExtractor()}

This method changes the format of the \ad object to 'SExtractor'. This means
that for all output to the screen or to a file the column info precedes the table
data.

\prgrf{Usage}
 adata\_object.toSExtractor()

\prgrf{Parameters}
-

\prgrf{Return}
-

\prgrf{Examples}
\begin{enumerate}
\item Load a plain \ad object, change to SExtractor format and
write it to a new file. Examine the output on the shell.
\begin{verbatim}
>>> example = asciidata.open('foo.txt')
>>> print example
    1    stars  1.0
    2 galaxies  2.0
    3     qsos  3.0
>>> example[0].rename('NUM')
>>> example[1].rename('CLASS')
>>> example[2].rename('MAG')
>>> example.toSExtractor()
>>> example.writeto('bar.txt')
>>>
~> more bar.txt
# 1  NUM
# 2  CLASS
# 3  MAG
    1    stars  1.0
    2 galaxies  2.0
    3     qsos  3.0
\end{verbatim}
\end{enumerate}

\subsubsection{AsciiData method tofits()}
\label{adm_tofits}
\index{methods}\index{methods!AsciiData!tofits()}
\index{tofits()}
%
The method transforms an \ad instance to a fits-table extension. This
extension might be used with other extensions to build a multi-extension
fits-file.\\
Please use the \ad method {\tt writetofits()}
(see Sect.\ \ref{adm_writetofits}) to make both, the conversions and
storing as a fits-file onto hard disk in one step.\\
The module \index{PyFITS}{\tt PyFITS} (see \htmladdnormallink{http://www.stsci.edu/resources/software\_hardware/pyfits}{http://www.stsci.edu/resources/software_hardware/pyfits})
must be installed to run this method. The transformation fails if the
\ad instance contains any {\tt Null} elements (due to a limitation
of the {\tt numpy} and {\tt numarray} objects, which are essential for the
method).


\prgrf{Usage}
aad\_object.tofits()

\prgrf{Parameters}
-

\prgrf{Return}
- a table fits extension

\prgrf{Examples}
\begin{enumerate}
\item Convert an \ad object to a fits-table extension and append it to an
already existing fits-table (the example is executed in PyRAF):
\begin{small}
\begin{verbatim}
--> catfits exa_table.fits
EXT#  FITSNAME      FILENAME              EXTVE DIMENS       BITPI OBJECT
0     exa_table.fit                                          16
1       BINTABLE    BEAM_1A                     14Fx55R            1
--> exa = asciidata.open('some_objects.cat')
--> tab_hdu = exa.tofits()
--> tab_all = pyfits.open('exa_table.fits', 'update')
--> tab_all.append(tab_hdu)
--> tab_all.close()
--> catfits exa_table.fits
EXT#  FITSNAME      FILENAME              EXTVE DIMENS       BITPI OBJECT
0     exa_table.fit                                          16
1       BINTABLE    BEAM_1A                     14Fx55R            1
2       BINTABLE                                5Fx3R
-->
\end{verbatim}
\end{small}
\end{enumerate}

